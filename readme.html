<!-- -*- mode: HTML; time-stamp-line-limit: -18; -*- -->
<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.0//EN">
<html>
    <head>
    <title>FSBV, Foreign Structures By Value
    </title>
    </head>
<h2>Description</h2>
<p>Call foreign functions when one or more
  arguments and/or the return value are structures.
  In CFFI and most Lisp foreign interfaces, structures must be passed
  by reference, that is, as pointers.  FSBV permits calling them by
  value.  It requires
  <a href="http://common-lisp.net/project/cffi/">CFFI</a>
  and <a href="http://sourceware.org/libffi/">libffi</a>.
  </p>
<h2>Example</h2>
<p> For example, the complex type is defined in
 the <a href="http://www.gnu.org/software/gsl/">GNU Scientific Library
(GSL)</a> as
<pre>
typedef struct
  {
    double dat[2];
  }
gsl_complex;
</pre>
<p>The function <code>gsl_complex_conjugate</code> takes and returns a
structure of this type by value,
<pre>
gsl_complex gsl_complex_conjugate (gsl_complex z);
</pre>
<p>If we define
<pre>
(defcstruct (complex :constructor complex :deconstructor (realpart imagpart))
  (dat :double :count 2))
(defcfun (complex-conjugate "gsl_complex_conjugate") complex
  (c complex))
</pre>
then we can call this function from Lisp: 
<pre>
(complex-conjugate #c(3.0d0 4.0d0))
#C(3.0 -4.0)
</pre>
<h2>Definitions</h2>
<p>The following definitions provide the call by value capability, and
  provide a convenient way of making equivalent Lisp and foreign
  objects:
  <ul>
    <li>Macro: <b>fsbv:defcstruct</b><var> name-and-options
    &amp;body doc-and-slots &rArr;
    name</var>
   <p>name-and-options ::= structure-name | (structure-name &amp;key
   constructor deconstructor)
   <p>doc-and-slots ::= [docstring] { (slot-name slot-type &amp;key
   count offset) }*
     <p>
     Define the foreign structure to Lisp.  The constructor is
     a symbol that when called on the components in order creates a
     Lisp object with the same contents as the foreign object; default
     is <code>list</code>.  The deconstructor is a symbol that when
     called on the Lisp object and a sequence number <i>n</i> selects
     the <i>n</i>-th component of that object, or it is a list of
     symbols that select the parts of the object in order; default
     is <code>elt</code>.
    </li>
    <li>Macro: <b>fsbv:defcfun</b><var> name-and-options return-type
	&amp;body </var>[<var>docstring</var>]<var>
	arguments </var>[<var>&amp;rest</var>]<var>
	&rArr; lisp-name<a name="index-defcfun-127"></a></var>
 <p><var>name-and-options</var> ::= name | (name)
  <var>name</var>
  ::= <var>lisp-name</var> [<var>foreign-name</var>] | <var>foreign-name</var> [<var>lisp-name</var>]
  <var>arguments</var> ::= { (arg-name arg-type) }*
      <p>This is used the same as
	<code><a href="http://common-lisp.net/project/cffi/manual/html_node/defcfun.html#defcfun">
	    cffi:defcfun</a></code>,
	except that options are not supported in <code>name-and-options</code>.
    </li>
    <li>Macro: <b>fsbv:foreign-funcall</b><var> name-and-options
    &amp;rest arguments &rArr;
    return-value</var> 
      <p>This is called the same as
	<code><a href="http://common-lisp.net/project/cffi/manual/html_node/foreign_002dfuncall.html#foreign_002dfuncall">cffi:foreign-funcall</a></code>,
	except that if the <i>name</i> is a symbol (as opposed to a
	string), the preparation defined by a
	previous <code>fsbv:defcfun</code> for that function name will
	be used.
	If foreign-funcall specifies no structures by value in its
	list of arguments or return type, it expands
	as <code>cffi:foreign-funcall</code>.
    </li>
    <li>Macro: <b>fsbv:defcenum-aux</b>
    (<var>name</var>)<var> &amp;optional (base-type :int)</var>
      <p>
	For the C enumeration <i>name</i> which has been defined using
      <code>cffi:defcenum</code>, make auxiliary definitions for
	FSBV.
    </li>
    <li>Macro: <b>fsbv:with-foreign-objects</b>
    (<var>bindings</var>)<var> &amp;body
    body</var>
      <p>bindings ::= {(var type &amp;optional initial-value)}*
	<p>
	Bind <i>var</i> to a pointer of a foreign object of
	type <i>type</i> which has optionally been initialized to
	the <i>initial-value</i>. 
    </li>
  </ul>
  <p>
    There are also functions <b>fsbv:object</b> and <b>(setf
    fsbv:object)</b> that create the Lisp object
    from the foreign pointer and type, and vice versa.
    They are used internally but are exported for the convenience of
    users.  When FSBV is loaded, it will put <code>:fsbv</code> in
    <code>*features*</code>. 
  <p>
  Note: <i>all</i> arguments to the function, and the return value,
  will gain an additional layer of indirection.  This means that
  arguments normally sent by reference (as a pointer) will require a
  pointer to the pointer.
</p>
<h2>Copying</h2>
<p>Copyright &copy; 2009 Liam Healy &lt;lhealy at common-lisp.net&gt;

   <blockquote>
Permission is hereby granted, free of charge, to any person obtaining
a copy of this software and associated documentation files (the
&ldquo;Software&rdquo;), to deal in the Software without restriction, including
without limitation the rights to use, copy, modify, merge, publish,
distribute, sublicense, and/or sell copies of the Software, and to
permit persons to whom the Software is furnished to do so, subject to
the following conditions:

        <p>The above copyright notice and this permission notice shall be
included in all copies or substantial portions of the Software.

        <p><span class="sc">The software is provided &ldquo;as is&rdquo;, without warranty of any kind,
express or implied, including but not limited to the warranties of
merchantability, fitness for a particular purpose and noninfringement. 
In no event shall the authors or copyright holders be liable for any
claim, damages or other liability, whether in an action of contract,
tort or otherwise, arising from, out of or in connection with the
software or the use or other dealings in the software.</span>
</blockquote>

<br>
<hr>
<small>
Time-stamp: <2009-05-03 12:12:50EDT readme.html>
</small>

</html>
